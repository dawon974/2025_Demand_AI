# -*- coding: utf-8 -*-
"""New+Regression_시프트 연산.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WZdQgO8lSbudvTGciMbhlEkLS90Ysfc6
"""

# 1. 라이브러리 설치 (Colab 전용)
# !pip install tensorflow scikit-learn pandas openpyxl

# 2. 라이브러리 불러오기
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Bidirectional, Dropout
import matplotlib.pyplot as plt

# 3. 데이터 불러오기
df = pd.read_excel("/content/drive/MyDrive/파주지사_A.I예측추가(2022~2025).xlsx")

# 4. 컬럼 정리 및 전처리
df.columns = df.columns.str.strip()
df.rename(columns={
    '열수요실적': 'Actual',
    '기상청실적': 'temperature',
    '일자': 'Date',
    '시간': 'Hour',
    '열수요예측': 'Demand_Prediction',
    'A.I': 'AI_Prediction'
}, inplace=True)
df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
df['Hour'] = pd.to_numeric(df['Hour'], errors='coerce')

# 5. 24시 처리
df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
df['Hour'] = pd.to_numeric(df['Hour'], errors='coerce')
df.loc[df['Hour'] == 24, 'Date'] += pd.Timedelta(days=1)
df.loc[df['Hour'] == 24, 'Hour'] = 0
df['datetime'] = pd.to_datetime(df['Date'].dt.date.astype(str) + ' ' + df['Hour'].astype(int).astype(str) + ':00:00')


# 6. 파생 변수 및 시차 피처 생성
df = df.sort_values('datetime')
df['dayofyear'] = df['Date'].dt.dayofyear / 365
df['weekday'] = df['Date'].dt.weekday / 6
df['month'] = df['Date'].dt.month / 12
df['hour'] = df['Hour'] / 24
df['Actual_shift1'] = df['Actual'].shift(1)
df['Actual_shift2'] = df['Actual'].shift(2)
df['Actual_shift24'] = df['Actual'].shift(24)
df['temp_shift3'] = df['temperature'].shift(3)
df['temp_shift6'] = df['temperature'].shift(6)
df['temp_shift9'] = df['temperature'].shift(9)

# 7. 모델 입력 정리
df_model = df.dropna()
X_cols = ['dayofyear', 'weekday', 'month', 'hour', 'temperature',
          'temp_shift3', 'temp_shift6', 'temp_shift9',
          'Actual_shift1', 'Actual_shift2', 'Actual_shift24']
scaler_X = MinMaxScaler()
scaler_y = MinMaxScaler()
X_scaled = scaler_X.fit_transform(df_model[X_cols])
y_scaled = scaler_y.fit_transform(df_model[['Actual']])

# 8. 시계열 시퀀스 생성
def create_sequences(X, y, time_steps=24):
    Xs, ys = [], []
    for i in range(time_steps, len(X)):
        Xs.append(X[i-time_steps:i])
        ys.append(y[i])
    return np.array(Xs), np.array(ys)

X_seq, y_seq = create_sequences(X_scaled, y_scaled)

# 9. LSTM 모델 학습
model = Sequential()
model.add(Bidirectional(LSTM(64, return_sequences=True, activation='tanh'), input_shape=(X_seq.shape[1], X_seq.shape[2])))
model.add(Bidirectional(LSTM(32, activation='tanh')))
model.add(Dropout(0.2))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mse')
model.fit(X_seq, y_seq, epochs=20, verbose=1)

# 10. 예측 및 복원
y_pred_scaled = model.predict(X_seq)
y_pred = scaler_y.inverse_transform(y_pred_scaled).flatten()
actual = scaler_y.inverse_transform(y_seq).flatten()

df_result = df_model.iloc[24:].copy().reset_index(drop=True)
df_result['LSTM_Prediction'] = y_pred

# 11. 선형 회귀 학습 및 예측
X_lr_scaled = scaler_X.transform(df_result[X_cols])
linear_model = LinearRegression()
linear_model.fit(X_lr_scaled, df_result['Actual'])
df_result['Linear_Prediction'] = linear_model.predict(X_lr_scaled)

# 12. AI/수요 예측값 병합
merge_base = df[['Date', 'Hour', 'AI_Prediction', 'Demand_Prediction']]
df_result = df_result.merge(merge_base, on=['Date', 'Hour'], how='left')

# 13. 시각화 (특정 날짜)
target_date = '2025-04-30'
day_plot = df_result[df_result['Date'] == pd.to_datetime(target_date)].copy()
raw_plot = df[df['Date'] == pd.to_datetime(target_date)].copy()  # ← 누락된 부분 추가

plt.figure(figsize=(12, 6))
plt.plot(day_plot['Hour'], day_plot['Actual'], label='Actual', linewidth=2)
plt.plot(day_plot['Hour'], day_plot['LSTM_Prediction'], label='New (LSTM)', linestyle='--')
plt.plot(day_plot['Hour'], day_plot['Linear_Prediction'], label='Linear Regression', linestyle='-.')

# AI & 수요 예측 추가
plt.plot(raw_plot['Hour'], raw_plot['AI_Prediction'], label='AI Prediction', linestyle=':', color='orange')
plt.plot(raw_plot['Hour'], raw_plot['Demand_Prediction'], label='Demand Prediction', linestyle=':', color='red')

plt.title(f"Heat Demand Forecast Comparison on {target_date}")
plt.xlabel("Hour")
plt.ylabel("Heat Demand")
plt.legend()
plt.grid(True)
plt.xticks(range(0, 25))
plt.tight_layout()
plt.show()

merge_base = df[['Date', 'Hour', 'AI_Prediction', 'Demand_Prediction']]
df_result = df_result.merge(merge_base, on=['Date', 'Hour'], how='left')

# 오차율 계산 함수 (MAPE 기준, 0 또는 이상치 예외 처리)
def calc_error(pred, actual):
    error = np.abs(pred - actual) / actual * 100
    return np.where((actual == 0) | (error > 200), np.nan, error)

# 오차율 컬럼 생성
df_result['Error_LSTM (%)'] = calc_error(df_result['LSTM_Prediction'], df_result['Actual'])
df_result['Error_Linear (%)'] = calc_error(df_result['Linear_Prediction'], df_result['Actual'])
df_result['Error_AI (%)'] = calc_error(df_result['AI_Prediction'], df_result['Actual'])
df_result['Error_Demand (%)'] = calc_error(df_result['Demand_Prediction'], df_result['Actual'])

#  월 정보 추가
df_result['Month'] = df_result['Date'].dt.month

# 월별 평균 오차율 계산
monthly_avg = df_result.groupby('Month')[
    ['Error_LSTM (%)', 'Error_Linear (%)', 'Error_AI (%)', 'Error_Demand (%)']
].mean().round(2).reset_index()

#  컬럼명 보기 좋게 변경
monthly_avg.rename(columns={
    'Error_LSTM (%)': 'New 오차율(%)',
    'Error_Linear (%)': '선형 회귀 오차율(%)',
    'Error_AI (%)': 'AI 예측 오차율(%)',
    'Error_Demand (%)': '열수요 예측 오차율(%)'
}, inplace=True)

#  월 이름 추가 및 열 순서 정리
monthly_avg['월'] = monthly_avg['Month'].astype(str) + "월"
monthly_avg = monthly_avg[['월', 'New 오차율(%)', '선형 회귀 오차율(%)', 'AI 예측 오차율(%)', '열수요 예측 오차율(%)']]

#  테이블 출력
from IPython.display import display
display(monthly_avg)