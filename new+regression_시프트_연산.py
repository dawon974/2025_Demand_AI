# -*- coding: utf-8 -*-
"""New+Regression_시프트 연산.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WZdQgO8lSbudvTGciMbhlEkLS90Ysfc6
"""

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Dropout
import matplotlib.pyplot as plt

#구글 드라이브 연동
from google.colab import drive
drive.mount('/content/drive')

# 엑셀 파일 불러오기
df = pd.read_excel("/content/drive/MyDrive/파주지사_A.I예측추가(2022~2025).xlsx")

#전처리
df.columns = df.columns.str.strip()
df.rename(columns={
    '열수요실적': 'Actual',
    '기상청실적': 'temperature',
    '일자': 'Date',
    '시간': 'Hour',
    '열수요예측': 'Demand_Prediction',
    'A.I': 'AI_Prediction'
}, inplace=True)

df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
df = df.dropna(subset=['Date'])
df['dayofyear'] = df['Date'].dt.dayofyear / 365
df['weekday'] = df['Date'].dt.weekday / 6
df['month'] = df['Date'].dt.month / 12
df['hour'] = df['Hour'].astype(int) / 24

# 24시 처리 → 다음날 0시로 이동
df.loc[df['Hour'] == 24, 'Date'] += pd.Timedelta(days=1)
df.loc[df['Hour'] == 24, 'Hour'] = 0

# datetime 생성
df['datetime'] = pd.to_datetime(df['Date'].dt.date.astype(str) + ' ' + df['Hour'].astype(int).astype(str) + ':00:00')
df = df.sort_values('datetime')

#시차 피처 생성
df['Actual_shift1'] = df['Actual'].shift(1)
df['Actual_shift2'] = df['Actual'].shift(2)
df['Actual_shift24'] = df['Actual'].shift(24)
df['temp_shift3'] = df['temperature'].shift(3)
df['temp_shift6'] = df['temperature'].shift(6)
df['temp_shift9'] = df['temperature'].shift(9)


#모델 학습용 데이터 구성
df_model = df[['Date', 'Hour', 'dayofyear', 'weekday', 'month', 'hour', 'temperature',
               'temp_shift3', 'temp_shift6', 'temp_shift9',
               'Actual_shift1', 'Actual_shift2', 'Actual_shift24', 'Actual']].dropna()

#정규화
X_cols = ['dayofyear', 'weekday', 'month', 'hour', 'temperature',
          'temp_shift3', 'temp_shift6', 'temp_shift9',
          'Actual_shift1', 'Actual_shift2', 'Actual_shift24']
scaler_X = MinMaxScaler()
scaler_y = MinMaxScaler()
X_scaled = scaler_X.fit_transform(df_model[X_cols])
y_scaled = scaler_y.fit_transform(df_model[['Actual']])

#시계열 시퀀스 구성
def create_sequences(X, y, time_steps=24):
    Xs, ys = [], []
    for i in range(time_steps, len(X)):
        Xs.append(X[i-time_steps:i])
        ys.append(y[i])
    return np.array(Xs), np.array(ys)

X_seq, y_seq = create_sequences(X_scaled, y_scaled)

#LSTM 모델 정의 및 학습
model = Sequential()
model.add(LSTM(64, return_sequences=True, input_shape=(X_seq.shape[1], X_seq.shape[2]), activation='tanh'))
model.add(LSTM(32, activation='tanh'))
model.add(Dropout(0.2))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mse')
model.fit(X_seq, y_seq, epochs=20, verbose=1)

# 예측 및 복원
y_pred_scaled = model.predict(X_seq)
y_pred = scaler_y.inverse_transform(y_pred_scaled).flatten()

# 결과 저장
df_result = df_model.iloc[24:].copy().reset_index(drop=True)
df_result['LSTM_Prediction'] = y_pred
df_result['LSTM_Prediction_Clipped'] = df_result['LSTM_Prediction'].clip(
    lower=df_result['Actual'].min() * 0.85,
    upper=df_result['Actual'].max() * 1.15
)
df_result['LSTM_Smoothed'] = df_result.groupby('Date')['LSTM_Prediction_Clipped'].transform(
    lambda x: x.rolling(window=3, min_periods=1, center=True).mean()
)

#선형 회귀 모델
df_result['연중일'] = df_result['Date'].dt.dayofyear
df_result['요일'] = df_result['Date'].dt.weekday
X_lr = df_result[['연중일', 'Hour', '요일', 'temperature',
                  'temp_shift3', 'temp_shift6', 'temp_shift9',
                  'Actual_shift1', 'Actual_shift2', 'Actual_shift24']]
y_lr = df_result['Actual']

scaler_lr = MinMaxScaler()
X_lr_scaled = scaler_lr.fit_transform(X_lr)
linear_model = LinearRegression()
linear_model.fit(X_lr_scaled, y_lr)
df_result['Linear_Prediction'] = linear_model.predict(X_lr_scaled)

#정확도 비교 출력
print(" 정확도 비교 (2025-04-30 10시 이후 기준 데이터)\n")
models = {
    'LSTM_Smoothed': df_result['LSTM_Smoothed'],
    'Linear Regression': df_result['Linear_Prediction']
}
actual = df_result['Actual'].values
for name, pred in models.items():
    mse = mean_squared_error(actual, pred)
    mae = mean_absolute_error(actual, pred)
    r2 = r2_score(actual, pred)
    print(f"[{name}]")
    print(f" MSE : {mse:.2f}")
    print(f" MAE : {mae:.2f}")
    print(f" R²  : {r2:.4f}\n")

#시각화 (4가지 예측 비교)
target_date = '2025-04-30'  # 원하는 날짜 지정
compare_day = df_result[df_result['Date'] == target_date].copy()
raw_day = df[df['Date'] == target_date].copy()

plt.figure(figsize=(12, 6))
plt.plot(compare_day['Hour'], compare_day['Actual'], label='Actual', linewidth=2)
plt.plot(compare_day['Hour'], compare_day['LSTM_Smoothed'], label='New', linestyle='--')
plt.plot(compare_day['Hour'], compare_day['Linear_Prediction'], label='Linear Regression', linestyle='-.')
plt.plot(raw_day['Hour'], raw_day['AI_Prediction'], label='AI Prediction', linestyle=':', color='orange')
plt.plot(raw_day['Hour'], raw_day['Demand_Prediction'], label='Demand Prediction', linestyle=':', color='red')

plt.title(f"Heat Demand Forecast Comparison on {target_date}")
plt.xlabel("Hour")
plt.ylabel("Heat Demand")
plt.legend()
plt.grid(True)
plt.xticks(range(0, 25))
plt.tight_layout()
plt.show()

# 원본 예측 데이터 병합 (AI, Demand)
raw_subset = df[['Date', 'Hour', 'AI_Prediction', 'Demand_Prediction']]
df_merge = df_result.merge(raw_subset, on=['Date', 'Hour'], how='left')

#오차율 계산 함수 정의
def calc_error(pred, actual):
    error = np.abs(pred - actual) / actual * 100
    return np.where((actual == 0) | (error > 200), np.nan, error)

#오차율 계산
df_merge['Error_New (%)'] = calc_error(df_merge['LSTM_Smoothed'], df_merge['Actual'])
df_merge['Error_Linear (%)'] = calc_error(df_merge['Linear_Prediction'], df_merge['Actual'])
df_merge['Error_AI (%)'] = calc_error(df_merge['AI_Prediction'], df_merge['Actual'])
df_merge['Error_Demand (%)'] = calc_error(df_merge['Demand_Prediction'], df_merge['Actual'])

#inf 값 정리
df_merge.replace([np.inf, -np.inf], np.nan, inplace=True)

#전체 평균 오차율 비교 출력
print("전체 예측 평균 오차율 (%)\n")
errors = {
    "New (LSTM)": df_merge['Error_New (%)'],
    "Linear Regression": df_merge['Error_Linear (%)'],
    "AI Prediction": df_merge['Error_AI (%)'],
    "Demand Prediction": df_merge['Error_Demand (%)']
}

for name, err in errors.items():
    mean_err = np.nanmean(err)
    print(f"[{name}] 평균 오차율: {mean_err:.2f} %")

#월별 오차율 평균 비교
df_merge['Month'] = df_merge['Date'].dt.month
monthly_avg = df_merge.groupby('Month')[[
    'Error_New (%)', 'Error_Linear (%)', 'Error_AI (%)', 'Error_Demand (%)'
]].mean().round(2).reset_index()

#보기 좋게 정리
monthly_avg.rename(columns={
    'Error_New (%)': 'New 오차율(%)',
    'Error_Linear (%)': '선형 회귀 오차율(%)',
    'Error_AI (%)': 'AI 예측 오차율(%)',
    'Error_Demand (%)': '열수요 예측 오차율(%)'
}, inplace=True)

monthly_avg['월'] = monthly_avg['Month'].astype(str) + "월"
monthly_avg = monthly_avg[['월', 'New 오차율(%)', '선형 회귀 오차율(%)', 'AI 예측 오차율(%)', '열수요 예측 오차율(%)']]

#화면 출력
from IPython.display import display
display(monthly_avg)