# -*- coding: utf-8 -*-
"""250509_LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1shsfyJYrPwqGtvCe-At5EQhpEm3qFmVI
"""

from tensorflow import keras
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
import seaborn as sns
import os
from datetime import datetime

#INFO 및 WARNING 로그는 출력되지 않고 ERROR 로그만 출력
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

from google.colab import drive
drive.mount('/content/drive')

#데이터 불러오고 상위 5개, 데이터에 대한 전반적인 정보, 컬럼별 요약 통계량 표시
data = pd.read_csv("/content/drive/MyDrive/MicrosoftStock.csv")
print(data.head())
print(data.info())
print(data.describe())

# Initial Data Visualization(초기 데이터 시각화)
# Plot 1 - Open and Close Prices of time
plt.figure(figsize=(12,6))
plt.plot(data['date'], data['open'], label="Open",color="blue")
plt.plot(data['date'], data['close'], label="Close",color="red")
plt.title("Open-Close Price over Time")
plt.legend()
# plt.show()

# Plot 2 - Trading Volume(거래량) (check for outliers)
plt.figure(figsize=(12,6))
plt.plot(data['date'],data['volume'],label="Volume",color="orange")
plt.title("Stock Volume over Time")
# plt.show()

# Drop non-numeric columns
numeric_data = data.select_dtypes(include=["int64","float64"])

# Plot 3 - Check for correlation between features
plt.figure(figsize=(8,6))
#수치 칼럼 간 상관계수 도출, 상관계수 수치 표시, 컬러맵 지정
sns.heatmap(numeric_data.corr(), annot=True, cmap="coolwarm")
plt.title("Feature Correlation Heatmap")
# plt.show()

"""open, high, low, close 상관정도는 1또는 거의 1로 매우 강한 양의 상관관계(주가의 시작/최고/최저/종가는 서로 밀접한 관계)

volume vs 나머지는 음의 상관관계로 거래량이 많을 수록 가격이 낮아지는 경향

index vs 나머지는 데이터 순서용으로 보이나, 가격과 강한 상관을 가짐
"""

# Convert the Data into Date time then create a date filter
#날짜 데이터를 datetime 형식으로 변환
data['date'] = pd.to_datetime(data['date'])

#2013년부터 2018년 사이의 데이터 필터링
prediction = data.loc[
    (data['date'] > datetime(2013,1,1)) &
    (data['date'] < datetime(2018,1,1))
]

#전체 data에서 날짜(date)를 x축, 종가(close)를 y축으로 시각화
plt.figure(figsize=(12,6))
plt.plot(data['date'], data['close'],color="blue")
plt.xlabel("Date")
plt.ylabel("Close")
plt.title("Price over time")

"""**LSTM 모델 학습을 위한 시계열 데이터 전처리 과정**"""

# Prepare for the LSTM Model (Sequential)
#close열만 추출해서 stock_close라는 새로운 DataFrame 만든다.
#즉, 종가만 모델 학습에 사용
stock_close = data.filter(["close"])
dataset = stock_close.values #convert to numpy array
#전체 데이터 중 95%를 훈련데이터로, 5%는 테스트데이터로 ceil()을 이용해 무조건 올림 처리
training_data_len = int(np.ceil(len(dataset) * 0.95))

"""**입력 데이터 전처리(Preprocessing)**"""

# Preprocessing Stages
#StandardScaler는 데이터를 평균 0, 표준편차 1로 정규화
scaler = StandardScaler()

#종가 데이터 정규화
scaled_data = scaler.fit_transform(dataset)

#전체 데이터 중 앞의 95% 구간만 잘라서 training_data로 사용합니다.
#이 구간은 학습용 데이터이며, 나머지는 검증/테스트용
training_data = scaled_data[:training_data_len] #95% of all out data

#시계열 예측을 위한 입력 (X) 과 목표 값 (y) 리스트를 초기화
X_train, y_train = [], []

"""**슬라이딩 윈도우 방식 시계열 전처리(LSTM 모델에 입력할 데이터를 만드는)**"""

# Create a sliding window for our stock (60 days)

#i는 60부터 시작, 처음 60일은 입력 데이터 시퀀스로 사용
#X_train i 이전 60일간의 데이터
#y_train 60일 뒤 1일의 값(예측 목표)
for i in range(60, len(training_data)):
    X_train.append(training_data[i-60:i, 0])
    y_train.append(training_data[i,0])

X_train, y_train = np.array(X_train), np.array(y_train)


#LSTM 3D 입력을 요구하므로 reshape
X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

"""**LSTM 기반 시계열 예측 모델 구축 및 학습**"""

# Build the Model
model = keras.models.Sequential()

# First Layer
model.add(keras.layers.LSTM(64, return_sequences=True, input_shape=(X_train.shape[1],1)))

# Second Layer
model.add(keras.layers.LSTM(64, return_sequences=False))

#활성화 함수 relu 사용
# 3rd Layer (Dense)
model.add(keras.layers.Dense(128, activation="relu"))

# 4th Layer (Dropout)
model.add(keras.layers.Dropout(0.5))

# Final Output Layer
model.add(keras.layers.Dense(1))

#옵티마이저 : Adam, 손실함수 : MAE, 평가지표 : RMSE
model.summary()
model.compile(optimizer="adam",
              loss="mae",
              metrics=[keras.metrics.RootMeanSquaredError()])


training = model.fit(X_train, y_train, epochs=20, batch_size=32)

"""***MAE***
모델의 예측값과 실제값의 차이의 절대값의 평균  
***MSE***
모델의 예측값과 실제값 차이의 면적의(제곱)합  
***RMSE***
모델의 예측값과 실제값의 차이의 절대값의 평균, 오류 지표를 실제값과 유사한 단위로 다시 변환

**미래 주가를 예측하기 위한 테스트 데이터 준비**
"""

# Prep the test data
#테스트 구간을 학습 구간 바로 뒤
#슬라이딩 윈도우 방식 때문에 이전 60일 데이터를 포함해야하기 때문에 -60
test_data = scaled_data[training_data_len - 60:]
X_test, y_test = [], dataset[training_data_len:]

#60일 입력 시퀀스를 반복해서 X_test에 저장
#X_test[i]는 테스트 시작 지점부터 60일간의 데이터
for i in range(60, len(test_data)):
    X_test.append(test_data[i-60:i, 0])

X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0],X_test.shape[1],1 ))

"""**LSTM 모델의 예측 결과를 복원(역정규화)**"""

# Make a Prediction
#X_test에 대해 종가 예측 수행
predictions = model.predict(X_test)
#원래 종가 값 범위로 역정규화
predictions = scaler.inverse_transform(predictions)

# Plotting data
train = data[:training_data_len]
test =  data[training_data_len:]

test = test.copy()

test['Predictions'] = predictions

plt.figure(figsize=(12,8))
#훈련데이터의 실제 종가
plt.plot(train['date'], train['close'], label="Train (Actual)", color='blue')
#테스트 데이터의 실제 종가
plt.plot(test['date'], test['close'], label="Test (Actual)", color='orange')
#테스트 기간의 예측 종가
plt.plot(test['date'], test['Predictions'], label="Predictions", color='red')
plt.title("Our Stock Predictions")
plt.xlabel("Date")
plt.ylabel("Close Price")
plt.legend()
plt.show()

"""과거 60일 데이터를 기반으로 테스트 기간의 종가 흐름을 잘 예측  
빨간선과 주황선이 비슷한 흐름을 보이므로 모델이 주가 흐름을 잘 파악한것으로 보임
"""